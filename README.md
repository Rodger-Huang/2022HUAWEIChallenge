# HUAWEICHALLENGE2022合作指南
## 关于代码
(大家可以把建议更新在这里)
- 请大家务必将功能模块化，写成一个个函数
- 希望大家在该注释的地方写好注释
- 变量命名建议（下划线方式，注意语义谢谢！），例如：qos_constraint, site_bandwidth_limit...
- 函数命名建议（驼峰式），例如：getSiteBandwidth(), getClientDemand()...

## 关于提交
1. 提交前检查代码中文件路径是否正确

**数据读取在目录`/data`下**

**数据保存在文件`/output/solution.txt`中**

2. 生成压缩文件[CodeCraft-2022.zip](SDK_python/CodeCraft-2022.zip)：
```
bash SDK_python/CodeCraft_zip.sh
```
## 目录管理
大家可以把不同的方案写成不同的py文件，放在目录SDK_python/CodeCraft-2022/solutions下。要测试的话就把相应内容copy到SDK_python/CodeCraft-2022/src/CodeCraft-2022.py。或者是在SDK_python/CodeCraft-2022/src/CodeCraft-2022.py中进行import的调用。

## 方案说明
请大家把解题思路更新在这里

思路：（以下均为某一单独时刻的情况）
如果按某种顺序考虑用户节点的需求，并将带宽需求以某种方式分配到满足Qos要求的边缘节点上。不可否认可能会出现无法满足用户节点需求的情况（不可行解），举例如下：
按上述顺序，最后一个用户节点带宽需求为100，满足其Qos要求的边缘节点只有一个，该边缘节点的带宽上限为120，但是在迭代到该用户节点之前已经分配40带宽给其他用户节点，故当前用户节点带宽需求无法被满足80＜100，出现矛盾。
当出现矛盾时如何调整其他用户节点与边缘节点之间的分配关系，我认为是一件较为复杂的事情，暂时没有好的解决方案，所以我认为应该考虑将 如何避免不可行解 作为出发点（这里我想问问大家这样的思路是否合理，或者有没有其他的思路可以一起讨论）。
若以此作为解题思路的话，接下来需要考虑的是上述顺序及分配方案如何定义，即以哪种顺序考虑用户节点，和以哪种方式分配多少带宽至各满足QoS要求的边缘节点。
这里我暂时想了几种优先级方案，有效性暂时不确定，需要编程实践验证效果：
用户节点顺序：
1. 总带宽需求 升序or降序
2. 满足Qos要求的边缘节点数 升序or降序
3. 总带宽需求/满足Qos要求的边缘节点数（姑且称之为压力吧） 升序or降序

边缘节点带宽分配方案：
1. 平均分配，Too Naive，极有可能出现不可行解
2. 加权分配：
1. 以各自连接的满足Qos需求的用户节点数作为权重（这里我之后补充公式），连接的用户节点数越多，分配给该边缘节点的带宽越少
2. 以当前空闲带宽（带宽上限减去已分配出去的带宽）作为权重（补充公式），空闲带宽越多，分配给该边缘节点的带宽越多

大家集思广益一下，有不同的思路，或者有新的合理的优先级方案都可以讨论和补充！


### 复赛方案
#### 方案一
- 代码文件: read_write.cpp
- 主要思路：测试读写, 只包含初始解,对每个时间步每个客户(客户按照对应站点数目从少到多排序):对其每个需求,按照顺序(应该是读入文件的默认顺序)检查站点,站点可用就给它塞进去.
- 练习赛分数:3633503

#### 方案二
- 代码文件: simple_initial_plus_greedy.cpp
- 主要思路: 在read_write的初始解基础上,加上了我们初赛使用的贪心,贪心的时候站点排序规则为:先考虑95%位值,由少到多,再考虑对应客户数目多少,同样也是由少到多. 95%前的塞到95%, 95%后的就尽量塞满.
- 练习赛分数:2668126

#### 方案三
- 代码文件: simple_initial_plus_V_greedy.cpp
- 主要思路:在方案二的基础上对贪心作了一点修改(加了一个if和value_95赋值), 95%位值不满V的就令95%位值为V,后续操作就会变为,不满V的塞满V,满V的尽可能塞满.
- 练习赛分数:1726487

#### 方案四
- 代码文件: sorted_initial_plus_V_greedy.cpp
- 主要思路:对方案三的求初始解那里进行了修改.对每个时间步每个客户(客户按照对应站点数目从少到多排序):对其每个需求,按照顺序(应该是读入文件的默认顺序)检查站点(增加修改:站点是按照对应客户数目从少到多排序的),站点可用就给它塞进去.
- 练习赛分数:1923472
- 备注:试了一下站点按照对应客户数目由多到少排序提交,分数:1372126
  (有点迷惑,大概是数据集的原因,猜测数据方差较大)

#### 方案五
- 代码文件：sorted_initial_plus_push_pull_V_greedy.cpp, heplers.hpp
- 主要思路：在方案四的基础上进行了改进，改的是后续贪心的部分。原来我们贪心是每个站点去拉取（pull）别的站点的流量。现在这个方案在pull之前增加一个push。具体做法如下：首先对每个站点初始解之后的95%位值排序，找出那些95%位值大于V的站点，把它们加到一个集合A里面，同时，找出所有时间步为0的站点，把它们加到另一个集合B里面。然后，对每一个集合A中的站点s1，在集合B中找一个或多个站点去分担s1的多个时间步的流量（首先使用一个集合B的站点，在95%前的所有时间步给s1分担流量，s1流量还没降到V一下，就再用多一个集合B的站点，以此类推。在集合B中选站点的原则是，找和s1有尽可能多的共同客户的站点）。
  push操作完之后，再进行原来的pull操作。
- 练习赛分数：1195377

#### 方案六

- 主要思路：平均初始解+pull
- score: 910218

#### 方案七
- 代码文件: average_initial_plus_V_push_pull.cpp
- 主要思路：平均初始解+Vpush+pull
- score:905606

#### 方案八
- current best score = 736400
- 代码文件：greedy_initial_plus_V_push_pull.cpp
- 主要思路：贪心初始解+Vpush+pull
  计算每个站点每个时间步最大可能服务的带宽量，找出最大的那些（每个站点填95%位之后的位置）先分配这些情况，剩下的按照平均分进行。
- score:871690
- 改了两行代码之后 score:805507
- 增加了一个参数并调参之后 **score:736400** （初始贪心那个函数ref_param>0.3得到的分数，如果用公共客户数目大于1判断得到747840分）

#### 方案九
- 代码文件：greedy_initial_plus_two_push_Vpull.cpp
- 主要思路：贪心初始解1（所有站点所有时间步计算一次来取最多的贪心）+Vpush+Vmore_push+pull
  第二次push试图拉到V之上。
- score:908268??加上Vmore_push之后还变差了。。。？？？

#### 方案十

- 代码文件:greedy2_initial.cpp
- 主要思路：贪心初始解2（站点按顺序来，每个计算时间步最多可能服务量来贪心，每个站点计算会更新分配情况）+简单平均+push+pull（95%前拉到V的部分可选择注释）
- score：869408

#### 方案十一

- 代码文件：greedy2_new_average_initial.cpp
- 主要思路：贪心初始解2（站点按顺序来，每个计算时间步最多可能服务量来贪心，每个站点计算会更新分配情况（95%前拉到V可选择注释）+选择站点剩余/使用量（或者使用一个系数）来平均+push+pull
- score：仅初始解400多w

#### 方案十二

- 代码文件：greedy3_initial.cpp
- 主要思路：贪心初始解3（在贪心2的基础上，对大站点对应的所有客户流量一起排序了，从大到小进行分配）（95%前拉到V可选择注释）+简单平均+push+pull
- score：？

#### 方案十三

- 代码文件：greedy3_new_average_initial.cpp
- 主要思路：贪心初始解3（在贪心2的基础上，对大站点对应的所有客户流量一起排序了，从大到小进行分配）（95%前拉到V可选择注释）+选择站点剩余/使用量（或者使用一个系数）来平均+push+pull
- score：？

#### 方案十四

- 代码文件：greedy_new_average_initial.cpp
- 主要思路：贪心初始解（站点按顺序来，每个计算时间步最多可能服务量来贪心，每个站点计算会更新分配情况）+选择站点剩余/使用量（或者使用一个系数）来平均+push+pull
- score：？



### 方案对比

比较贪心+平均初始解不同组合的方案

贪心1：一次计算，所有站点所有时间步，计算可能服务的流量大小。给所有的排序，每次挑最大的，挑够后5%（同时统计每个站点各自是否取够后5%位置，若够了就跳过这个站点）

贪心2：站点顺序为对应客户数目从多到少，对每个站点计算所有时间步可能服务的流量大小，排序，取最大的5%，直接分配，下一个站点考虑的时候就不考虑已被分配的流。

贪心3：站点顺序为对应客户数目从多到少，对每个站点计算所有时间步可能服务的流量大小，排序，取最大的5%，直接分配，下一个站点考虑的时候就不考虑已被分配的流。分配的时候将所有客户流量进行排序，从大到小吸收流量（其实可能没必要，就线下数据来看的话极少有用尽带宽的情况）

平均1：客户按照读入顺序，流也按照读入顺序，对于每个流，轮流分给site

平均2：客户按照读入顺序，流也按照读入顺序，对于每个流，检查每个站点，选取剩余带宽最多的那个站点

平均3：客户按照读入顺序，流也按照读入顺序，对于每个流，检查每个站点，选取剩余带宽最少的那个站点

平均4：客户按照读入顺序，流也按照读入顺序，对于每个流，检查每个站点，选取使用带宽最少的那个站点（由于线下站点带宽一样，所以和平均2一样）



| 方案                          | （仅初始解）线下分数 | （一次push&pull）线下分数 | 线上分数（仅初始解）                | 线上（初始解+push&pull 2次）                                 | 线下运行时间（初始解） |
| ----------------------------- | -------------------- | ------------------------- | ----------------------------------- | ------------------------------------------------------------ | ---------------------- |
| 贪心1+平均1（方案八）         | 144046               | 39417                     |                                     | 736400                                                       | 7.738                  |
| 贪心1+平均2                   | 163903               | 43394                     |                                     |                                                              | 8.645                  |
| 贪心1+平均3                   | 99338                | 37658                     |                                     |                                                              | 8.084                  |
| 贪心1+平均4                   | 163903               | 43394                     |                                     |                                                              | 10.667                 |
| 贪心2+平均1                   | 87215                | 38156                     |                                     |                                                              | 7.724                  |
| 贪心2+平均2                   | 83376                | 36758                     |                                     |                                                              | 10.283                 |
| 贪心2+平均3                   | 29122                | 24612                     | 加了塞满V的：；没有塞满V的：        | 加了塞满V的：；（一次push pull，否则超时）没有塞满V的：824025； | 9.557                  |
| 贪心2+平均4                   | 83376                | 36758                     | 加了塞满V的：6290602；没有塞满V的： | 加了塞满V的：；没有塞满V的：?                                | 11.724                 |
| 贪心2+平均4（变为系数）       | 82789                |                           |                                     |                                                              |                        |
| 贪心2+平均4（变为系数+塞满V） | 72453                |                           |                                     |                                                              |                        |
| 贪心3+平均1                   | 95873                | 37191                     |                                     |                                                              | 8.682                  |
| 贪心3+平均2                   |                      |                           |                                     |                                                              |                        |
| 贪心3+平均3                   |                      |                           |                                     |                                                              |                        |
| 贪心3+平均4                   |                      |                           |                                     |                                                              |                        |

塞满V之后好像后续push和pull比较难改进了？



## 其他有用的库
1. 测试指标生成：[CodeCraft2022-benchmark](https://github.com/diphosphane/CodeCraft2022-benchmark)
2. 压测数据生成：[CodeCraft2022-PressureGenerator](https://github.com/diphosphane/CodeCraft2022-PressureGenerator)

